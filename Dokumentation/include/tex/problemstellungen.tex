\section{Problemstellungen}
\label{sec:problemstellungen}
In diesem Kapitel soll der Fokus auf die aufgetretenen Probleme und Schwierigkeiten gelegt werden. Die Problemstellungen reichen hierbei von generellen Schwierigkeiten bis zu ganz speziellen Problemen, die gegebenenfalls nur in dieser Konstellation auftreten würden.

\subsection{Sprachschwierigkeiten}
Das generellste Problem ist offensichtlich. Es wurde zuvor nicht mit Kotlin gearbeitet, entsprechend gab es hier bereits die einen oder anderen Startschwierigkeiten. Problematischer als die Eigenheiten von Kotlin gestaltet sich aber, dass nach wie vor die meisten Apps in Java geschrieben werden. Entsprechend sieht es auch bei den Dokumentationen zu Bibliotheken aus. Die meisten Beispiele sind schlicht in Java geschrieben.

Android Studio als Entwicklungsumgebung bietet zwar die Möglichkeit Java in Kotlin Code umzuwandeln, doch klappt das nicht immer perfekt. Speziell bei den Features bezüglich Null-Safety treten im umgewandelten Code Probleme auf. Entweder weil es schlicht nicht berücksichtigt wurde, dann ist das Code nicht ohne Weiteres kompilierbar, oder weil Variablen, die möglicherweise den Wert "null" haben könnten, werden hinsichtlich dieser Eigenschaft ignoriert. D.h. es wird einfach auf die Variable zugegriffen und im Worst-Case wird eine NullPointerException ausgeworfen.

\subsection{Auswahl der Persistierungsart}
Da in BOSCall auch Daten gespeichert werden müssen, z.B. die Einheiten, Alarmierungen und Einstellungen, ist es notwendig die verschiedenen Arten der Persistierung zu evaluieren.

Der erste Anwendungsfall für die Persistierung war die Speicherung der registrierten Einheiten. Zunächst wurde darüber nachgedacht, die Daten in einer SQLite Datenbank abzulegen. Zu diesem Zeitpunkt erschien es aber zunächst zu komplex und es war wichtiger die Alarmierungsfunktionalität zu realisieren. Aus diesem Grund wurde die Entscheidung getroffen, die Einheiten im JSON Format als .json-Datei auf dem internen Dateisystem abzulegen. Zur effektiven Verarbeitung von JSON Strings wurde im Rahmen der Anwendung die Google GSON Bibliothek\cite{Github:GSON} verwendet.

Mit zunehmender Anzahl an persistenten Daten fiel die Entscheidung darauf, für alle weiteren Daten auf SQLite zu setzen. Da die SQLite Funktionalität von Android aber etwas komplizierter für ausschweifende Arbeiten ist und auch keine native Unterstützung für die Abbildung der Daten in der Datenbank auf Objekte bietet, wurde Room verwendet. Die Verwendung von Room ist auch die Empfehlung von Google.\cite{Android:DBDocumentation}

Room bietet den großen Vorteil des Objekt Mappings. D.~h. es wird von SQL abstrahiert. Man spart sich damit also Klassen zu schreiben, die sich nur mit der Datenbank Kommunikation beschäftigen. Der Verbindungsauf- und -abbau und die Auswertung von Daten zu komplexen Objekten wird durch Room erledigt.

\subsection{Kommunikation mit dem Backend}
Die Kommunikation mit dem Backend erfolgt über HTTP im REST Stil. Auch hier bringt Android bzw. Java Möglich"-keiten mit, um mit dem Service zu kommunizieren. Ebenfalls erfolgt mit diesen kein automatisches Mapping der Daten (vorliegend in JSON) zu komplexen Objekten.

Es gäbe es die Möglichkeit das Mapping manuell selbst zu schreiben, was aber aufgrund des zusätzlichen Aufwands und des hohen Fehlerpotentials ausgeschlossen wurde. Stattdessen wurde auf eine getestete Bibliothek zurückgegriffen, die diese und weitere Funktionalitäten mitbringt. Aufgrund der guten Dokumentation und der bereits nicht zu verachtenden Gemeinschaft um das Projekt, fiel die Entscheidung auf Retrofit.\cite{Github:Retrofit} Die kurze und verständliche Dokumentation, sowie die umfangreichen Tutorials im Internet, machten diese Entscheidung recht leicht.

\subsection{FCM - Notification Message oder Data Message}
Diese Problematik tritt in Verbindung mit Firebase Cloud Messaging (FCM) auf, das in diesem Projekt für die Push Nachrichten erforderlich ist. Die Wahl fiel auf insbesondere deshalb auf Firebase, weil das Projekt von Google betrieben wird und die Implementierung in BOSCall entsprechend leicht zu realisieren war. Die Integration wird zusätzlich durch Android Studio unterstützt. Nicht zuletzt war aber der größte Vorteil, dass die Nutzung von Firebase Cloud Messaging, im Gegensatz zu anderen Push Dienstleistern kostenlos ist.

Das Hauptproblem bei der Nutzung von FCM entstand, wenn man prüft wie sich die App im Hintergrund verhält, wenn z.B. das Gerät gesperrt ist. Dabei fiel auf, dass die Nachrichten nur als Notification ausgeliefert wurden, aber nicht die programmierten Empfangsroutinen durchlaufen wurden. Wenn man die Notification anschließend angeklickt hat um die App zu öffnen, kam man auch nur an die Daten dieser einzelnen Notification, die anderen wurden sofort gelöscht. Damit gehen effektiv Alarmierungsdaten verloren, die für das alarmierte Personal essentiell sein könnten. Ein Beispiel: Es wird zunächst normal zu einem Gebäudebrand alarmiert. Bei der Alarmierung werden die Adressdaten der Einsatzstelle übertragen. Im Anschluss wird ein zweites mal alarmiert um darin mitzuteilen, dass die Anfahrt aufgrund einer Straßensperrung über einen anderen Straßenzug erfolgt. Klickt der Alarmierte nun den neuesten, also den zweiten, Alarm an, fehlt ihm die Adresse um die Einsatzstelle überhaupt anfahren zu können.

Eine Lösung des Problems wäre, das alle ausgelösten Alarmierungen auch auf dem virtuellen Server gespeichert werden. Sobald jemand die App öffnet werden alle Alarmierungen abgerufen, die noch nicht auf dem Endgerät gespeichert wurden. Das hat aber einen gravierenden Nachteil. Denn dazu müssten alle Alarmierungen, inklusive sensibler Daten, auf dem virtuellen Server gespeichert werden. Aus Datenschutzgründen sollte das vermieden werden.

Nach einer intensiven Recherche war klar, dass bei FCM zwischen zwei Arten einer Push Nachricht unterschieden wird. Zunächst die Notification Message. Diese hat die oben genannte Problematik wenn die App sich im Hintergrund befindet. Zusätzlich gibt es aber auch die Möglichkeit Data Messages zu versenden. Um eine solche Nachricht zu verschicken, kann man nicht die Admin Console von Firebase verwenden, was bereits für einige Verwirrung sorgte, da zum Testen bis dahin immer die Admin Console verwendet wurde. Es ist erforderlich eine der angebotenen Schnittstellen zu verwenden. Für das BOSCall Projekt bedeutete das eine weitere Verzögerung, da zunächst ein Alarmprogramm unter Nutzung der FCM Admin SDK entwickelt werden musste. Dazu gibt es diverse Tutorials, die aber für unterschiedliche Versionen von FCM geschrieben wurden und entsprechend im Laufe der Zeit nicht mehr in einem funktionsfähigen Programm endeten. Nachdem diese Schwierigkeiten überwunden waren, stellte sich schnell heraus, dass an der App keine weiteren Änderungen erforderlich sind. Denn bei Empfang einer Data Message durchläuft unabhängig vom aktuellen Zustand der App (Vorder- oder Hintergrund) jede Nachricht die bereits zuvor geschriebenen Routine.